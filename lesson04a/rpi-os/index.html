
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      <link rel="shortcut icon" href="../../assets/favicon.png">
      <meta name="generator" content="mkdocs-1.1.2, mkdocs-material-6.2.6">
    
    
      
        <title>exp4a - p1-kernel</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.cb6bc1d0.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.39b8e14a.min.css">
        
          
          
          <meta name="theme-color" content="#4051b5">
        
      
    
    
    
      
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>body,input{font-family:"Roboto",-apple-system,BlinkMacSystemFont,Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono",SFMono-Regular,Consolas,Menlo,monospace}</style>
      
    
    
    
    
      
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo">
      
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#4a-cooperative-multitasking" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid" aria-label="Header">
    <a href="../.." title="p1-kernel" class="md-header-nav__button md-logo" aria-label="p1-kernel">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 89 89"><path d="M3.136 17.387v42.932l42.932 21.467L3.136 17.387z"/><path d="M21.91 8l42.933 64.398-18.775 9.388L3.136 17.387 21.91 8z" fill-opacity=".5"/><path d="M67.535 17.387L40.273 35.543l21.878 32.818 5.384 2.691V17.387z"/><path d="M67.535 17.387v53.666l18.774-9.388V8l-18.774 9.387z" fill-opacity=".25"/></svg>

    </a>
    <label class="md-header-nav__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg>
    </label>
    <div class="md-header-nav__title" data-md-component="header-title">
      <div class="md-header-nav__ellipsis">
        <div class="md-header-nav__topic">
          <span class="md-ellipsis">
            p1-kernel
          </span>
        </div>
        <div class="md-header-nav__topic">
          <span class="md-ellipsis">
            
              exp4a
            
          </span>
        </div>
      </div>
    </div>
    
      <label class="md-header-nav__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
      </label>
      
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" data-md-state="active" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </label>
      <button type="reset" class="md-search__icon md-icon" aria-label="Clear" data-md-component="search-reset" tabindex="-1">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
<nav class="md-tabs" aria-label="Tabs" data-md-component="tabs">
  <div class="md-tabs__inner md-grid">
    <ul class="md-tabs__list">
      
        
  
  


  <li class="md-tabs__item">
    <a href="../../lesson00/rpi-os/" class="md-tabs__link">
      exp0
    </a>
  </li>

      
        
  
  


  <li class="md-tabs__item">
    <a href="../../lesson01/rpi-os/" class="md-tabs__link">
      exp1
    </a>
  </li>

      
        
  
  


  <li class="md-tabs__item">
    <a href="../../lesson02/rpi-os/" class="md-tabs__link">
      exp2
    </a>
  </li>

      
        
  
  


  <li class="md-tabs__item">
    <a href="../../lesson03/rpi-os/" class="md-tabs__link">
      exp3
    </a>
  </li>

      
        
  
  
    
  


  <li class="md-tabs__item">
    <a href="./" class="md-tabs__link md-tabs__link--active">
      exp4a
    </a>
  </li>

      
        
  
  


  <li class="md-tabs__item">
    <a href="../../lesson04b/rpi-os/" class="md-tabs__link">
      exp4b
    </a>
  </li>

      
        
  
  


  <li class="md-tabs__item">
    <a href="../../lesson05/rpi-os/" class="md-tabs__link">
      exp5
    </a>
  </li>

      
        
  
  


  <li class="md-tabs__item">
    <a href="../../lesson06/rpi-os/" class="md-tabs__link">
      exp6
    </a>
  </li>

      
        
  
  


  <li class="md-tabs__item">
    <a href="../../qemu/" class="md-tabs__link">
      /qemu
    </a>
  </li>

      
        
  
  


  <li class="md-tabs__item">
    <a href="../../gdb/" class="md-tabs__link">
      /gdb
    </a>
  </li>

      
        
  
  


  <li class="md-tabs__item">
    <a href="../../cheatsheet/" class="md-tabs__link">
      /aarch64
    </a>
  </li>

      
        
  
  


  <li class="md-tabs__item">
    <a href="../../ssh-proxy/" class="md-tabs__link">
      /ssh
    </a>
  </li>

      
        
  
  


  <li class="md-tabs__item">
    <a href="../../dump/" class="md-tabs__link">
      /dump
    </a>
  </li>

      
    </ul>
  </div>
</nav>
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="p1-kernel" class="md-nav__button md-logo" aria-label="p1-kernel">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 89 89"><path d="M3.136 17.387v42.932l42.932 21.467L3.136 17.387z"/><path d="M21.91 8l42.933 64.398-18.775 9.388L3.136 17.387 21.91 8z" fill-opacity=".5"/><path d="M67.535 17.387L40.273 35.543l21.878 32.818 5.384 2.691V17.387z"/><path d="M67.535 17.387v53.666l18.774-9.388V8l-18.774 9.387z" fill-opacity=".25"/></svg>

    </a>
    p1-kernel
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../lesson00/rpi-os/" class="md-nav__link">
        exp0
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../lesson01/rpi-os/" class="md-nav__link">
        exp1
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../lesson02/rpi-os/" class="md-nav__link">
        exp2
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../lesson03/rpi-os/" class="md-nav__link">
        exp3
      </a>
    </li>
  

    
      
      
      

  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          exp4a
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        exp4a
      </a>
      
        
<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#roadmap" class="md-nav__link">
    Roadmap
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#key-data-structures" class="md-nav__link">
    Key data structures
  </a>
  
    <nav class="md-nav" aria-label="Key data structures">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#task_struct" class="md-nav__link">
    task_struct
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#functions" class="md-nav__link">
    Functions
  </a>
  
    <nav class="md-nav" aria-label="Functions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#preparing-task_structs-kernelc" class="md-nav__link">
    Preparing task_structs (kernel.c)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#switching-tasks-schedc-scheds" class="md-nav__link">
    Switching tasks (sched.c &amp; sched.S)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#launching-a-new-task" class="md-nav__link">
    Launching a new task
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ret_from_fork-entrys" class="md-nav__link">
    ret_from_fork (entry.S)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#aside-memory-allocation" class="md-nav__link">
    Aside: Memory allocation
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#the-scheduler" class="md-nav__link">
    The scheduler
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#conclusion" class="md-nav__link">
    Conclusion
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../lesson04b/rpi-os/" class="md-nav__link">
        exp4b
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../lesson05/rpi-os/" class="md-nav__link">
        exp5
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../lesson06/rpi-os/" class="md-nav__link">
        exp6
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../qemu/" class="md-nav__link">
        /qemu
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../gdb/" class="md-nav__link">
        /gdb
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../cheatsheet/" class="md-nav__link">
        /aarch64
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../ssh-proxy/" class="md-nav__link">
        /ssh
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../dump/" class="md-nav__link">
        /dump
      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#roadmap" class="md-nav__link">
    Roadmap
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#key-data-structures" class="md-nav__link">
    Key data structures
  </a>
  
    <nav class="md-nav" aria-label="Key data structures">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#task_struct" class="md-nav__link">
    task_struct
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#functions" class="md-nav__link">
    Functions
  </a>
  
    <nav class="md-nav" aria-label="Functions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#preparing-task_structs-kernelc" class="md-nav__link">
    Preparing task_structs (kernel.c)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#switching-tasks-schedc-scheds" class="md-nav__link">
    Switching tasks (sched.c &amp; sched.S)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#launching-a-new-task" class="md-nav__link">
    Launching a new task
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ret_from_fork-entrys" class="md-nav__link">
    ret_from_fork (entry.S)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#aside-memory-allocation" class="md-nav__link">
    Aside: Memory allocation
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#the-scheduler" class="md-nav__link">
    The scheduler
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#conclusion" class="md-nav__link">
    Conclusion
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                
                <h1 id="4a-cooperative-multitasking">4a: Cooperative Multitasking</h1>
<p>We will build a minimum kernel that can schedule multiple cooperative tasks. </p>
<p><img alt="" src="../qemu-sched.gif" /></p>
<h2 id="roadmap">Roadmap</h2>
<p>From this experiment onward, our kernel starts to schedule multiple tasks. This makes it a true "kernel" instead of a baremetal program. </p>
<p>We will intentionally leave out interrupts, i.e. <strong>timer interrupts are OFF</strong>. Tasks must voluntarily yield to each other. As a result, we focus on scheduling and task switch and defer treatment of interrupt handling to upcoming experiment. . </p>
<p>We will implement: </p>
<ol>
<li>The <code>task_struct</code> data structure </li>
<li>Task creation by manipulating <code>task_struct</code>, registers, and stack</li>
<li>Minimalist memory allocation</li>
<li>A minimalist task scheduler 
   <!--- counter. must be maintained in timer_tick() for accounting ... --->
</li>
</ol>
<p><strong>Processes vs tasks</strong>. As we do not have virtual memory yet, we use the term "tasks" instead of "processes". </p>
<h2 id="key-data-structures">Key data structures</h2>
<p><img alt="" src="sched/Slide1.png" /> 
<em>An array of pointers to task_structs of tasks</em> </p>
<h3 id="task_struct">task_struct</h3>
<p>To manage tasks, the first thing we should do is to create a struct that describes a task. Linux has such a struct and it is called <code>task_struct</code>  (in Linux both thread and processes are just different types of tasks; the difference is in how they share address spaces). As we are mostly mimicking Linux implementation, we are going to do the same. It looks like the following (in sched.h).</p>
<pre><code>struct cpu_context {
    unsigned long x19;
    unsigned long x20;
    unsigned long x21;
    unsigned long x22;
    unsigned long x23;
    unsigned long x24;
    unsigned long x25;
    unsigned long x26;
    unsigned long x27;
    unsigned long x28;
    unsigned long fp;
    unsigned long sp;
    unsigned long pc;
};

struct task_struct {
    struct cpu_context cpu_context;
    long state;
    long counter;
    long priority;
    long preempt_count;
};
</code></pre>
<p>This struct has the following members:</p>
<ul>
<li><code>cpu_context</code> This is an embedded structure that contains values of all registers that might be different between the tasks, that are being switched. </li>
<li>Why don't we save all registers, but only registers <code>x19 - x30</code> and <code>sp</code>? (<code>fp</code> is <code>x29</code> and <code>pc</code> is <code>x30</code>). Because task switch happens only when a task calls <a href="https://github.com/s-matyukevich/raspberry-pi-os/blob/master/src/lesson04/src/sched.S#L4">cpu_switch_to</a> function. </li>
<li>So, from the point of view of the task that is being switched, it just calls <code>cpu_switch_to</code> function and it returns after some (potentially long) time. The "switched from" task doesn't notice that another task happens to runs during this period.  </li>
<li>Accordingly to ARM calling conventions registers <code>x0 - x18</code> can be overwritten by the callee, so the caller must not assume that the values of those registers will survive after a function call. That's why it doesn't make sense to save <code>x0 - x18</code> registers.</li>
<li><code>state</code> This is the state of the currently running task (note: NOT CPU state which is an orthogonal concept). For tasks that are just doing CPU work but not IO, the state will always be <a href="https://github.com/s-matyukevich/raspberry-pi-os/blob/master/src/lesson04/include/sched.h#L15">TASK_RUNNING</a>. For now, this is the only state supported by our kernel. </li>
<li>Later we add a few additional states. For example, a task that is waiting for an interrupt should be moved to a different state, because it doesn't make sense to awake the task while the required interrupt hasn't yet happened.</li>
<li><code>counter</code> This field is used to determine how long the current task has been running. <code>counter</code> decreases by 1 each timer tick and when it reaches 0 another task is scheduled. This supports our simple scheduling algorithm.</li>
<li><code>priority</code>  When a new task is scheduled its <code>priority</code> is copied to <code>counter</code>. By setting tasks priority, we can regulate the amount of processor time that the task gets relative to other tasks.</li>
<li><code>preempt_count</code> If this field has a non-zero value it is an indicator that right now the current task is executing some critical function that must not be interrupted (for example, it runs the scheduling function.). If timer tick occurs at such time it is ignored and rescheduling is not triggered.</li>
</ul>
<p>After the kernel startup, there is only one task running: the one that runs kernel_main(). It is called "init task". Before the scheduler is enabled, we must fill <code>task_struct</code> of the init task. This is done in <code>INIT_TASK</code>.</p>
<p>All <code>task_struct</code>s are stored in <code>task</code> (sched.c) array. This array has only 64 slots - that is the maximum number of simultaneous tasks that we can have in the kernel. It won't suit a production OS, but it is ok for our goals.</p>
<p>An important global variable is <code>current</code> (sched.c) that always points to <code>task_struct</code> of currently executing task. Both <code>current</code> and <code>task</code> array are initially set to hold a pointer to the init task. There is also a global variable called <a href="https://github.com/s-matyukevich/raspberry-pi-os/blob/master/src/lesson04/src/sched.c#L8">nr_tasks</a> - it contains the number of currently running tasks in the system.</p>
<p>Those are all structures and global variables needed to implement the scheduler. In the description of the <code>task_struct</code> I already briefly mentioned some aspects of how scheduling works, because it is impossible to understand the meaning of a particular <code>task_struct</code> field without understanding how this field is used. </p>
<p>Now examine the scheduling algorithm in much more details and we will start with the <code>kernel_main</code> function.</p>
<h2 id="functions">Functions</h2>
<h3 id="preparing-task_structs-kernelc">Preparing task_structs (kernel.c)</h3>
<p>How to prove that the scheduler actually works? </p>
<pre><code>void kernel_main(void)
{
    uart_init();
    init_printf(0, putc);
    irq_vector_init();

    int res = copy_process((unsigned long)&amp;process, (unsigned long)&quot;12345&quot;);
    if (res != 0) {
        printf(&quot;error while starting process 1&quot;);
        return;
    }
    res = copy_process((unsigned long)&amp;process, (unsigned long)&quot;abcde&quot;);
    if (res != 0) {
        printf(&quot;error while starting process 2&quot;);
        return;
    }

    while (1){
        schedule();
    }
}
</code></pre>
<p>There are a few important things about this code.</p>
<ol>
<li>New function <a href="https://github.com/s-matyukevich/raspberry-pi-os/blob/master/src/lesson04/src/fork.c#L5">copy_process</a> is introduced. <code>copy_process</code> takes 2 arguments: a function to execute in a new thread and an argument that need to be passed to this function. <code>copy_process</code> allocates a new <code>task_struct</code>  and makes it available for the scheduler.</li>
<li>Another new function for us is called <a href="https://github.com/s-matyukevich/raspberry-pi-os/blob/master/src/lesson04/src/sched.c#L21">schedule</a>. This is the core scheduler function: it checks whether there is a new task that needs to preempt the current one. In cooperative scheduling, a task voluntarily calls <code>schedule</code> if it doesn't have any work to do at the moment. Spoiler: for preemptive multitasking, <code>schedule</code> is also called from the timer interrupt handler.</li>
</ol>
<blockquote>
<p>Try your self with QEMU: set a breakpoint at copy_process &amp; launch the kernel. Examine task_struct with <code>print *p</code>. Examine the value of cpu_context.[pc|sp|fn|arg]. </p>
</blockquote>
<p>We are calling <code>copy_process</code> 2 times, each time passing a pointer to the <a href="https://github.com/s-matyukevich/raspberry-pi-os/blob/master/src/lesson04/src/kernel.c#L9">process</a> function as the first argument. <code>process</code> function is very simple.</p>
<pre><code>void process(char *array)
{
    while (1){
        for (int i = 0; i &lt; 5; i++){
            uart_send(array[i]);
            delay(100000);
            schedule();
        }
    }
}
</code></pre>
<p>It just keeps printing on the screen characters from the array, that is passed as an argument The first time it is called with the argument "12345" and second time the argument is "abcde". After printing out a string, a task yields to others by calling <code>schedule()</code>. If our scheduler implementation is correct, we should see on the output from both threads.</p>
<h3 id="switching-tasks-schedc-scheds">Switching tasks (sched.c &amp; sched.S)</h3>
<p>This is where the magic happens. The code looks like this.</p>
<pre><code>void switch_to(struct task_struct * next)
{
    if (current == next)
        return;
    struct task_struct * prev = current;
    current = next;
    cpu_switch_to(prev, next);
}
</code></pre>
<p>Here we check that next process is not the same as the current, and if not, <code>current</code> variable is updated. The actual work is redirected to <a href="https://github.com/s-matyukevich/raspberry-pi-os/blob/master/src/lesson04/src/sched.S">cpu_switch_to</a> function. It is in assembly as it manipulates registers. </p>
<pre><code>.globl cpu_switch_to
cpu_switch_to:
    mov    x10, #THREAD_CPU_CONTEXT
    add    x8, x0, x10
    mov    x9, sp
    stp    x19, x20, [x8], #16        // store callee-saved registers
    stp    x21, x22, [x8], #16
    stp    x23, x24, [x8], #16
    stp    x25, x26, [x8], #16
    stp    x27, x28, [x8], #16
    stp    x29, x9, [x8], #16
    str    x30, [x8]
    add    x8, x1, x10
    ldp    x19, x20, [x8], #16        // restore callee-saved registers
    ldp    x21, x22, [x8], #16
    ldp    x23, x24, [x8], #16
    ldp    x25, x26, [x8], #16
    ldp    x27, x28, [x8], #16
    ldp    x29, x9, [x8], #16
    ldr    x30, [x8]
    mov    sp, x9
    ret
</code></pre>
<p>This is the place where the real context switch happens. Let's examine it line by line.</p>
<pre><code>    mov    x10, #THREAD_CPU_CONTEXT
    add    x8, x0, x10
</code></pre>
<p><code>THREAD_CPU_CONTEXT</code> constant contains offset of the <code>cpu_context</code> structure in the <code>task_struct</code>. <code>x0</code> contains a pointer to the first argument, which is the current <code>task_struct</code> (i.e. the "switch_from" task).  After the copied 2 lines are executed, <code>x8</code> will contain a pointer to the current <code>cpu_context</code>.</p>
<pre><code>    mov    x9, sp
    stp    x19, x20, [x8], #16        // store callee-saved registers
    stp    x21, x22, [x8], #16
    stp    x23, x24, [x8], #16
    stp    x25, x26, [x8], #16
    stp    x27, x28, [x8], #16
    stp    x29, x9, [x8], #16
    str    x30, [x8]
</code></pre>
<p><img alt="" src="../sched/Slide2.PNG" /></p>
<p><em>Figure above: Registers are being saved to task_struct.context</em></p>
<p>Next all callee-saved registers are stored in the order, in which they are defined in <code>cpu_context</code> structure. The current stack pointer is saved as <code>cpu_context.sp</code> and <code>x29</code> is saved as <code>cpu_context.fp</code> (frame pointer).</p>
<p>Note: <code>x30</code>, the link register containing function return address, is stored as <code>cpu_context.pc</code>. Why?</p>
<p>Now we calculate the address of the next task's <code>cpu_context</code>: </p>
<pre><code>    add    x8, x1, x10
</code></pre>
<p>This a cute hack. <code>x10</code> contains an offset of the <code>cpu_context</code> structure inside <code>task_struct</code>, <code>x1</code> is a pointer to the next <code>task_struct</code>, so <code>x8</code> will contain a pointer to the next <code>cpu_context</code>.</p>
<p>Now, restore the CPU context of "switch_to" task from memory to CPU regs. A mirror procedure. </p>
<pre><code>    ldp    x19, x20, [x8], #16        // restore callee-saved registers
    ldp    x21, x22, [x8], #16
    ldp    x23, x24, [x8], #16
    ldp    x25, x26, [x8], #16
    ldp    x27, x28, [x8], #16
    ldp    x29, x9, [x8], #16
    ldr    x30, [x8]
    mov    sp, x9
    ret
</code></pre>
<p>After <code>ret</code>, kernel returns to the location pointed to by the link register (<code>x30</code>). If we are switching to a task for the first time, this will be <a href="https://github.com/s-matyukevich/raspberry-pi-os/blob/master/src/lesson04/src/entry.S#L148">ret_from_fork</a> function. More on it below. In all other cases this will be the location, previously saved in the <code>cpu_context.pc</code> by the <code>cpu_switch_to</code> function. Think: which instruction does it point to? </p>
<h3 id="launching-a-new-task">Launching a new task</h3>
<p>After seeing task switch, new task creation starts to make more sense. It is implemented in <a href="https://github.com/s-matyukevich/raspberry-pi-os/blob/master/src/lesson04/src/fork.c#L5">copy_process</a> function.</p>
<p>Keep in mind: after <code>copy_process</code> finishes execution, no context switch happens. The function only prepares new <code>task_struct</code> and adds it to the <code>task</code> array â€” this task will be executed only after <code>schedule</code> function is called.</p>
<pre><code>int copy_process(unsigned long fn, unsigned long arg)
{
    struct task_struct *p;

    p = (struct task_struct *) get_free_page();
    if (!p)
        return 1;
    p-&gt;priority = current-&gt;priority;
    p-&gt;state = TASK_RUNNING;
    p-&gt;counter = p-&gt;priority;

    p-&gt;cpu_context.x19 = fn;
    p-&gt;cpu_context.x20 = arg;
    p-&gt;cpu_context.pc = (unsigned long)ret_from_fork;
    p-&gt;cpu_context.sp = (unsigned long)p + THREAD_SIZE;
    int pid = nr_tasks++;
    task[pid] = p;
    return 0;
}
</code></pre>
<p>Now, we are going to examine it in details.</p>
<pre><code>    struct task_struct *p;
</code></pre>
<p>The function starts with allocating a pointer for the new task. As interrupts are off, the kernel will not be interrupted in the middle of the <code>copy_process</code> function.</p>
<pre><code>    p = (struct task_struct *) get_free_page();
    if (!p)
        return 1;
</code></pre>
<p>Next, a new page is allocated. At the bottom of this page, we are putting the <code>task_struct</code> for the newly created task. The rest of this page will be used as the task stack. A few lines below, <code>context.sp</code> is set as <code>p + THREAD_SIZE</code>. THREAD_SIZE is defined as 4KB. It is the total amount of memory for a task. The name, again, is following the Linux kernel convention. </p>
<table>
<thead>
<tr>
<th align="center"><img alt="" src="sched/Slide3.png" /></th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><em>Figure above: a task's task_struct in relative to its stack space</em></td>
</tr>
</tbody>
</table>
<pre><code>    p-&gt;priority = current-&gt;priority;
    p-&gt;state = TASK_RUNNING;
    p-&gt;counter = p-&gt;priority;
</code></pre>
<p>After the <code>task_struct</code> is allocated, we can initialize its properties.  Priority and initial counters are set based on the current task priority. </p>
<pre><code>    p-&gt;cpu_context.x19 = fn;
    p-&gt;cpu_context.x20 = arg;
    p-&gt;cpu_context.pc = (unsigned long)ret_from_fork;
    p-&gt;cpu_context.sp = (unsigned long)p + THREAD_SIZE;
</code></pre>
<p>This is the most important part of the function. Here <code>cpu_context</code> is initialized. The stack pointer is set to the top of the newly allocated memory page. <code>pc</code>  is set to the <a href="https://github.com/s-matyukevich/raspberry-pi-os/blob/master/src/lesson04/src/entry.S#L146">ret_from_fork</a> function, and we need to look at this function now in order to understand why the rest of the <code>cpu_context</code> registers are initialized in the way they are.</p>
<h3 id="ret_from_fork-entrys">ret_from_fork (entry.S)</h3>
<p>This is the <strong>first</strong> piece of code executed by a newly created process. A new process P executes <code>ret_from_fork</code> after <strong>it is switched to</strong> for the first time. That is right after the scheduler picks P for the first time and restores P's CPU context from <code>task_struct</code> to CPU registers. Throughout its lifetime, P only executes <code>ret_from_fork</code> once. </p>
<blockquote>
<p>About naming: despite the name "fork", we are not doing fork() as in Linux/Unix. We are simply copying a <code>task_struct</code> while fork() does far more things like duplicating process address spaces. The naming follows the Linux kernel convention; and we will evolve our <code>ret_from_fork</code> in subsequent experiments. </p>
</blockquote>
<pre><code>.globl ret_from_fork
ret_from_fork:
    bl    schedule_tail // will talk about this later
    mov    x0, x20
    blr    x19         //should never return
</code></pre>
<p>Where do <code>x19</code> and <code>x20</code> come from? See code <code>copy_process</code> above, which saves <code>fn</code> (the process's main function) and <code>arg</code> (the argument passed to the process) to<code>task_struct</code>. When switching to P, the kernel restores <code>fn</code> and <code>arg</code> from <code>task_struct</code> to <code>x19</code> and <code>x20</code>. </p>
<p>As a result, <code>ret_from_fork</code> calls the function stored in <code>x19</code> register with the argument stored in <code>x20</code>. </p>
<blockquote>
<p>:wrench:Try your self with QEMU: set a breakpoint at ret_from_fork, launch the kernel, and single step into the new process function</p>
</blockquote>
<h3 id="aside-memory-allocation">Aside: Memory allocation</h3>
<p>Each task in the system should have its dedicated stack. That's why when creating a new task we must have a way to allocate memory. For now, our memory allocator is extremely primitive. (The implementation can be found in <a href="https://github.com/s-matyukevich/raspberry-pi-os/blob/master/src/lesson04/src/mm.c">mm.c</a> file)</p>
<pre><code>static unsigned short mem_map [ PAGING_PAGES ] = {0,};

unsigned long get_free_page()
{
    for (int i = 0; i &lt; PAGING_PAGES; i++){
        if (mem_map[i] == 0){
            mem_map[i] = 1;
            return LOW_MEMORY + i*PAGE_SIZE;
        }
    }
    return 0;
}

void free_page(unsigned long p){
    mem_map[(p - LOW_MEMORY) / PAGE_SIZE] = 0;
}
</code></pre>
<blockquote>
<p>:wrench: Try it yourself with QEMU: <code>ptype mem_map</code> then <code>print (short[10])*mem_map</code>. </p>
</blockquote>
<p>The allocator can work only with memory pages (each page is 4 KB in size). There is an array called <code>mem_map</code> that for each page in the system holds its status: whether it is allocated or free. Whenever we need to allocate a new page, we just loop through this array and return the first free page. This implementation is based on 2 assumptions:</p>
<ol>
<li>We know the total amount of memory in the system. It is <code>1 GB - 1 MB</code> (the last megabyte of memory is reserved for device registers.). This value is stored in the <a href="https://github.com/s-matyukevich/raspberry-pi-os/blob/master/src/lesson04/include/mm.h#L14">HIGH_MEMORY</a> constant.</li>
<li>First 4 MB of memory are reserved for the kernel image and init task stack. This value is stored in <a href="https://github.com/s-matyukevich/raspberry-pi-os/blob/master/src/lesson04/include/mm.h#L13">LOW_MEMORY</a> constant. All memory allocations start right after this point.</li>
</ol>
<blockquote>
<p>Note: even with QEMU our kernel must start from 0x80000 (512KB), the above assumptions are good as there's still plenty room in 512KB -- LOW_MEMORY for our tiny kernel.</p>
</blockquote>
<h3 id="the-scheduler">The scheduler</h3>
<p>Finally, we are ready to look at the scheduler algorithm. I almost precisely copied this algorithm from the first release of the Linux kernel. You can find the original version <a href="https://github.com/zavg/linux-0.01/blob/master/kernel/sched.c#L68">here</a>.</p>
<pre><code>void _schedule(void)
{
    int next,c;
    struct task_struct * p;
    while (1) {
        c = -1;
        next = 0;
        // try to pick a task
        for (int i = 0; i &lt; NR_TASKS; i++){
            p = task[i];
            if (p &amp;&amp; p-&gt;state == TASK_RUNNING &amp;&amp; p-&gt;counter &gt; c) {
                c = p-&gt;counter;
                next = i;
            }
        }
        if (c) {
            break;
        }
        // update counters
        for (int i = 0; i &lt; NR_TASKS; i++) {
            p = task[i];
            if (p) {
                p-&gt;counter = (p-&gt;counter &gt;&gt; 1) + p-&gt;priority;
            }
        }
    }
    switch_to(task[next]);
}
</code></pre>
<p>The simple algorithm works like the following:</p>
<ul>
<li>
<p>The first <code>for</code> loop iterates over all tasks and tries to find a task in <code>TASK_RUNNING</code> state with the maximum counter. If such a task is found, we immediately break from the <code>while</code> loop and switch to this task. </p>
</li>
<li>
<p>If no such task is found, this is either because i) no task is in <code>TASK_RUNNING</code>  state or ii) all such tasks have 0 counters. In a real OS, i) might happen, for example, when all tasks are waiting for an interrupt. In our current tiny kernel, all tasks are always in <code>TASK_RUNNING</code> (Why?) </p>
</li>
<li>
<p>The scheduler moves to the 2nd <code>for</code> loop to "recharge" counters. It bumps counters for all tasks once. The increment depends on a task's priority. Note: a task counter can never get larger than <code>2 * priority</code>.</p>
</li>
<li>
<p>With updated counters, the scheduler goes back to the 1st <code>for</code> loop to pick a task. </p>
</li>
</ul>
<p>We will augment the scheduling algorithm for preemptive multitasking later. </p>
<h3 id="conclusion">Conclusion</h3>
<p>We have seen important nuts &amp; bolts of multitasking. The subsequent experiment will enable task preemption. We will show a detailed workflow of context switch there. </p>
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid" aria-label="Footer">
        
          <a href="../../lesson03/rpi-os/" class="md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-footer-nav__button md-icon">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
            </div>
            <div class="md-footer-nav__title">
              <div class="md-ellipsis">
                <span class="md-footer-nav__direction">
                  Previous
                </span>
                exp3
              </div>
            </div>
          </a>
        
        
          <a href="../../lesson04b/rpi-os/" class="md-footer-nav__link md-footer-nav__link--next" rel="next">
            <div class="md-footer-nav__title">
              <div class="md-ellipsis">
                <span class="md-footer-nav__direction">
                  Next
                </span>
                exp4b
              </div>
            </div>
            <div class="md-footer-nav__button md-icon">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4z"/></svg>
            </div>
          </a>
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        Made with
        <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
          Material for MkDocs
        </a>
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../../assets/javascripts/vendor.53cc9318.min.js"></script>
      <script src="../../assets/javascripts/bundle.e9c9f54f.min.js"></script><script id="__lang" type="application/json">{"clipboard.copy": "Copy to clipboard", "clipboard.copied": "Copied to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "Search", "search.result.placeholder": "Type to start searching", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.term.missing": "Missing"}</script>
      
      <script>
        app = initialize({
          base: "../..",
          features: ['navigation.tabs'],
          search: Object.assign({
            worker: "../../assets/javascripts/worker/search.9c0e82ba.min.js"
          }, typeof search !== "undefined" && search)
        })
      </script>
      
    
  </body>
</html>